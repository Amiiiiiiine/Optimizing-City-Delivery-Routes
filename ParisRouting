# Import required standard libraries
import csv          # Used to read CSV files
import math         # Provides mathematical functions
import itertools    # Used to generate permutations (TSP brute-force)
import os           # Used for file path management


# CONFIGURATION


# Absolute path to the directory containing this script
# This ensures the script works regardless of the execution location
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Path to the CSV file containing metro station data
STATIONS_FILE = os.path.join(BASE_DIR, "metro.csv")



# GEOGRAPHICAL DISTANCE


def haversine(lat1, lon1, lat2, lon2):
    """
    Computes the geographical distance between two points on Earth
    given their latitude and longitude (in degrees),
    using the Haversine formula.

    Returns:
        float: distance in kilometers
    """
    R = 6371  # Mean radius of the Earth in kilometers

    # Convert coordinates from degrees to radians
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lon2 - lon1)

    # Haversine formula
    a = math.sin(dphi / 2) ** 2 + \
        math.cos(phi1) * math.cos(phi2) * math.sin(dlambda / 2) ** 2

    # Central angle and final distance
    return 2 * R * math.atan2(math.sqrt(a), math.sqrt(1 - a))



# LOADING STATION DATA


def load_stations():
    """
    Loads metro station data from a CSV file and stores each station
    in a dictionary indexed by the station name.
    """
    stations = {}

    # Open the CSV file using UTF-8 encoding
    with open(STATIONS_FILE, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f, delimiter=";")

        for row in reader:
            # Clean station name
            name = row["nom_arret"].strip()

            # Extract and split GPS coordinates
            gps = row["coordonné gps"].replace(" ", "")
            lat_str, lon_str = gps.split(",")

            # Avoid duplicate station entries
            if name not in stations:
                stations[name] = {
                    "name": name,
                    "lat": float(lat_str),
                    "lon": float(lon_str),
                    "line": row["ligne"],
                    "connections": row["changement de ligne possible"]
                }

    return stations



# TRAVELING SALESMAN PROBLEM (TSP)


def route_distance(route):
    """
    Computes the total distance of a given route by summing
    the distances between consecutive stations.
    """
    return sum(
        haversine(
            route[i]["lat"], route[i]["lon"],
            route[i + 1]["lat"], route[i + 1]["lon"]
        )
        for i in range(len(route) - 1)
    )


def find_shortest_route(stations):
    """
    Finds the shortest route visiting all selected stations
    exactly once using a brute-force approach to the
    Traveling Salesman Problem (TSP).

    Args:
        stations (list): list of station dictionaries

    Returns:
        tuple:
            - best_route (tuple): optimal station order
            - best_distance (float): total distance in kilometers
    """
    best_route = None
    best_distance = float("inf")

    # Iterate over all possible permutations of stations
    for perm in itertools.permutations(stations):
        dist = route_distance(perm)

        # Update the best solution if a shorter route is found
        if dist < best_distance:
            best_distance = dist
            best_route = perm

    return best_route, best_distance



# USER INTERFACE


def main():
    """
    Main program entry point:
    - Loads station data
    - Collects user input
    - Computes the optimal route
    - Displays the results
    """
    print("METRO ROUTE OPTIMIZATION (LAST MILE)\n")

    # Load station dataset
    stations_dict = load_stations()
    print(f"{len(stations_dict)} stations available\n")

    # User input instructions
    print("Enter the stations to visit (comma-separated)")
    print("Example: Châtelet, Bastille, République\n")

    user_input = input("> ")
    requested_names = [s.strip() for s in user_input.split(",")]

    # Validate user-selected stations
    requested_stations = []
    for name in requested_names:
        if name not in stations_dict:
            print(f"Unknown station: {name}")
            return
        requested_stations.append(stations_dict[name])

    # Ensure a valid number of stations
    if len(requested_stations) < 2:
        print("At least two stations are required")
        return

    # Warn about computational complexity
    if len(requested_stations) > 8:
        print("Warning: more than 8 stations may be very slow")

    print("\nComputing optimal route...\n")

    # Compute the optimal route
    route, distance = find_shortest_route(requested_stations)

    # Display the optimal route
    print("OPTIMAL ROUTE:\n")

    previous_line = None
    for i, station in enumerate(route, start=1):
        print(f"{i}. {station['name']} (Line {station['line']})")

        # Detect line changes between consecutive stations
        if previous_line and station["line"] != previous_line:
            print("   Line change")

        # Display possible transfer connections
        if station["connections"]:
            print(f"   Connections: {station['connections']}")

        previous_line = station["line"]

    # Display total walking distance
    print(f"\nTotal walking distance: {distance:.2f} km")


# Program entry point
if __name__ == "__main__":
    main()

